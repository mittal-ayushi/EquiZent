<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Equizent ‚Äî Fair Hangout Finder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #1f2937, #020617);
      color: white;
      display: flex;
      justify-content: center;
      padding: 24px;
    }

    .app {
      width: 100%;
      max-width: 1100px;
      background: rgba(15, 23, 42, 0.96);
      border-radius: 18px;
      padding: 24px;
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.6);
      border: 1px solid #1f2937;
    }

    h1 {
      font-size: 26px;
      margin: 0 0 6px;
    }

    p.subtitle {
      margin: 0;
      color: #9ca3af;
      max-width: 620px;
      font-size: 14px;
    }

    .grid {
      display: grid;
      grid-template-columns: minmax(0, 1.7fr) minmax(0, 1.3fr);
      gap: 20px;
      margin-top: 20px;
    }

    @media (max-width: 900px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: #020617;
      border-radius: 12px;
      border: 1px solid #1f2937;
      padding: 12px;
      margin-bottom: 10px;
    }

    .friend-card {
      margin-bottom: 10px;
      position: relative;
    }

    label {
      display: block;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #9ca3af;
      margin-bottom: 2px;
    }

    input, select {
      width: 100%;
      padding: 7px 9px;
      border-radius: 8px;
      border: 1px solid #374151;
      background: #020617;
      color: white;
      font-size: 13px;
      outline: none;
    }

    input::placeholder {
      color: #6b7280;
    }

    input[type="datetime-local"] {
      padding: 8px 9px;
      font-size: 14px;
      color: white;
      background: #0f172a;
      border: 1px solid #06b6d4;
    }

    input[type="datetime-local"]::-webkit-calendar-picker-indicator {
      filter: invert(1);
      cursor: pointer;
    }

    .friend-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      font-size: 13px;
      font-weight: 600;
    }

    .remove-friend-btn {
      background: #dc2626;
      border: none;
      color: white;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 11px;
      cursor: pointer;
      font-weight: 600;
    }

    .remove-friend-btn:hover {
      background: #b91c1c;
    }

    .add-friend-btn {
      background: #06b6d4;
      border: none;
      color: #020617;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 13px;
      cursor: pointer;
      font-weight: 600;
      margin-bottom: 10px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .add-friend-btn:hover {
      background: #0891b2;
    }

    .error {
      background: #450a0a;
      border: 1px solid #b91c1c;
      color: #fecaca;
      padding: 10px;
      border-radius: 8px;
      font-size: 13px;
      margin-bottom: 10px;
    }

    .btn-primary {
      border: none;
      border-radius: 999px;
      padding: 10px 18px;
      background: linear-gradient(135deg, #22c55e, #06b6d4);
      color: #020617;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .btn-primary:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .results-empty {
      border-radius: 12px;
      border: 1px dashed #374151;
      padding: 16px;
      color: #9ca3af;
      font-size: 14px;
    }

    .place-card {
      background: #020617;
      border-radius: 12px;
      border: 1px solid #1f2937;
      padding: 12px;
      margin-bottom: 8px;
      font-size: 13px;
      cursor: pointer;
      transition: border-color 0.2s;
    }

    .place-card:hover {
      border-color: #06b6d4;
    }

    .place-card.best {
      border-color: #22c55e;
    }

    .place-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
      gap: 12px;
    }

    .badge {
      background: #22c55e;
      color: #020617;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 11px;
      font-weight: 600;
      align-self: flex-start;
      white-space: nowrap;
    }

    .badge.equidistant {
      background: #3b82f6;
    }

    .badge.scheduled {
      background: #8b5cf6;
    }

    .muted {
      color: #9ca3af;
      font-size: 12px;
    }

    .time-row {
      display: flex;
      justify-content: space-between;
      margin-top: 6px;
      font-size: 12px;
      gap: 8px;
    }

    .spinner {
      display: inline-block;
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 2px solid #0f172a;
      border-top-color: #0f172a;
      border-right-color: transparent;
      border-bottom-color: transparent;
      border-left-color: transparent;
      animation: spin 0.7s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    small.help {
      display: block;
      color: #6b7280;
      font-size: 11px;
      margin-top: 4px;
    }

    .autocomplete-container {
      position: relative;
    }

    .autocomplete-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #1f2937;
      border: 1px solid #374151;
      border-radius: 8px;
      margin-top: 4px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
    }

    .autocomplete-dropdown.active {
      display: block;
    }

    .autocomplete-item {
      padding: 8px 10px;
      cursor: pointer;
      font-size: 13px;
      border-bottom: 1px solid #374151;
    }

    .autocomplete-item:last-child {
      border-bottom: none;
    }

    .autocomplete-item:hover {
      background: #374151;
    }

    .autocomplete-item-main {
      color: #e5e7eb;
      font-weight: 500;
    }

    #map {
      width: 100%;
      height: 400px;
      border-radius: 12px;
      margin-bottom: 10px;
      border: 1px solid #374151;
      background: #0f172a;
    }

    .map-container {
      display: none;
    }

    .map-container.active {
      display: block;
    }

    .leaflet-popup-content-wrapper {
      background: #1f2937;
      color: white;
      border-radius: 8px;
      padding: 8px;
    }

    .leaflet-popup-content {
      margin: 8px;
      font-size: 13px;
    }

    .leaflet-popup-tip {
      background: #1f2937;
    }

    .range-input-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 6px;
    }

    .range-input-container input[type="range"] {
      flex: 1;
      height: 6px;
      background: #374151;
      border-radius: 5px;
      outline: none;
      -webkit-appearance: none;
    }

    .range-input-container input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #06b6d4;
      cursor: pointer;
      border-radius: 50%;
    }

    .range-input-container input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #06b6d4;
      cursor: pointer;
      border-radius: 50%;
      border: none;
    }

    .range-value {
      min-width: 60px;
      text-align: right;
      color: #06b6d4;
      font-weight: 600;
      font-size: 12px;
    }

    .toggle-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .toggle-switch {
      position: relative;
      width: 50px;
      height: 26px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #374151;
      transition: 0.3s;
      border-radius: 34px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: #3b82f6;
    }

    input:checked + .toggle-slider:before {
      transform: translateX(24px);
    }

    .toggle-label {
      font-size: 13px;
      color: #e5e7eb;
      font-weight: 500;
    }

    .warning-badge {
      background: #f59e0b;
      color: #020617;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 11px;
      font-weight: 600;
      margin-left: 6px;
    }

    .range-section {
      display: none;
      margin-top: 6px;
    }

    .range-section.visible {
      display: block;
    }

    .mode-selector {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }

    .mode-btn {
      flex: 1;
      padding: 10px;
      border: 2px solid #374151;
      background: #020617;
      color: #9ca3af;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
    }

    .mode-btn:hover {
      border-color: #06b6d4;
    }

    .mode-btn.active {
      border-color: #06b6d4;
      background: rgba(6, 182, 212, 0.1);
      color: #06b6d4;
    }

    .traffic-indicator {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: 6px;
    }

    .traffic-indicator.heavy {
      background: rgba(239, 68, 68, 0.2);
      color: #fca5a5;
    }

    .traffic-indicator.moderate {
      background: rgba(245, 158, 11, 0.2);
      color: #fcd34d;
    }

    .traffic-indicator.light {
      background: rgba(34, 197, 94, 0.2);
      color: #86efac;
    }

    .place-details {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid #374151;
      font-size: 12px;
    }

    .detail-item {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 3px;
      color: #9ca3af;
    }

    .detail-item a {
      color: #60a5fa;
      text-decoration: none;
    }

    .detail-item a:hover {
      text-decoration: underline;
    }

    .datetime-input-wrapper {
      margin-top: 10px;
      padding: 12px;
      background: #0f172a;
      border-radius: 8px;
      border: 1px solid #06b6d4;
    }

    .datetime-label {
      font-size: 12px;
      font-weight: 600;
      color: #06b6d4;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    /* Leaflet controls styling for dark theme */
    .leaflet-control-attribution {
      background: rgba(15, 23, 42, 0.8) !important;
      color: #9ca3af !important;
    }

    .leaflet-control-zoom a {
      background: #1f2937 !important;
      color: white !important;
      border-color: #374151 !important;
    }

    .leaflet-control-zoom a:hover {
      background: #374151 !important;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Equizent ‚Äî Fair Hangout Finder</h1>
      <p class="subtitle">
        Add friends, set their locations and travel preferences, choose what you're looking for ‚Äî we'll
        find the best spots with traffic predictions for your scheduled time.
      </p>
    </header>

    <div class="grid">
      <!-- Left: inputs -->
      <div>
        <h3 style="margin-bottom:8px;font-size:16px;">Friend locations & preferences</h3>

        <button id="addFriendBtn" class="add-friend-btn">
          <span>‚ûï Add Friend</span>
        </button>

        <div id="friends-container"></div>

        <!-- Common preferences card -->
        <div class="card">
          <label>What are you looking for?</label>
          <select id="categorySelect">
            <option value="">Select a category...</option>
            <option value="food">üçΩÔ∏è Food & Drinks</option>
            <option value="entertainment">üé¨ Entertainment</option>
            <option value="shopping">üõçÔ∏è Shopping</option>
            <option value="sports">üèÉ Sports & Fitness</option>
            <option value="outdoor">üå≥ Outdoor & Nature</option>
            <option value="culture">üé® Arts & Culture</option>
            <option value="venues">üéâ Event Venues</option>
          </select>
          
          <div id="placeTypeContainer" style="margin-top:10px;display:none;">
            <label>Select specific place</label>
            <select id="placeType">
              <option value="">Choose...</option>
            </select>
          </div>
          
          <small class="help">
            Using OpenStreetMap + TomTom for place details.
          </small>
        </div>

        <!-- Distance Mode Selection -->
        <div class="card">
          <label>Distance Mode</label>
          <div class="mode-selector">
            <button class="mode-btn active" data-mode="equidistant">
               Equidistant
            </button>
            <button class="mode-btn" data-mode="custom">
              ‚öôÔ∏è Custom Range
            </button>
          </div>
          <small class="help" id="modeHelp">
            Everyone travels similar distances (most fair).
          </small>
        </div>

        <!-- Traffic & Time Scheduling -->
        <div class="card">
          <div class="toggle-container">
            <label class="toggle-switch">
              <input type="checkbox" id="trafficToggle" checked>
              <span class="toggle-slider"></span>
            </label>
            <span class="toggle-label">üö¶ Use traffic data</span>
          </div>
          
          <div class="toggle-container" style="margin-top:8px;">
            <label class="toggle-switch">
              <input type="checkbox" id="scheduleToggle">
              <span class="toggle-slider"></span>
            </label>
            <span class="toggle-label">‚è∞ Schedule for specific time</span>
          </div>

          <div id="dateTimeWrapper" style="display:none;">
            <div class="datetime-input-wrapper">
              <div class="datetime-label">
                üìÖ Select Date & Time
              </div>
              <input type="datetime-local" id="scheduleDateTime" />
            </div>
            <small class="help" style="margin-top:6px;">
              Traffic predictions up to 24 hours ahead.
            </small>
          </div>
        </div>

        <div id="errorBox" class="error" style="display:none;"></div>

        <button id="findButton" class="btn-primary">
          <span>üîç Find places</span>
          <span id="btnSpinner" class="spinner" style="display:none;"></span>
        </button>
      </div>

      <!-- Right: results -->
      <div>
        <h3 style="margin-bottom:8px;font-size:16px;">Suggested spots</h3>
        
        <!-- Map Container -->
        <div id="mapContainer" class="map-container">
          <div id="map"></div>
        </div>

        <div id="resultsContainer" class="results-empty">
          Add at least 2 friends, fill in their locations, select what you're looking for, and click
          <strong>"Find places"</strong> to see suggestions here.
        </div>
      </div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    const LATLONG_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJUb2tlbklEIjoiMzNmMjY3MTgtMjRiOC00NTFlLWJlMGYtOGZmMzA1ZDI3ZDk5IiwiQ2xpZW50SUQiOiI2YTA3ZDNkMC01MTNkLTRjMTMtYjRjMi04NTdiY2YzNDJiNWIiLCJCdW5pdElEIjozMCwiQXBwTmFtZSI6InBlcyBoYWNrYXRob24gbWFwcy1yZWltYWdpbmVkIiwiQXBwSUQiOjE4Mzk1LCJUaW1lU3RhbXAiOiIyMDI1LTExLTI4IDE3OjEyOjUyIiwiZXhwIjoxNzY0NTIyNzcyfQ.q5AqBLmiB3KlPMt58O5N767uBJ6qNxGmt6X2aYWtrbI";
    
    const TOMTOM_API_KEY = "XRX0dSIxQBTqYgv5kXuHogm1F0E39cvV";  

    let friends = [];
    let nextFriendId = 1;
    let map = null;
    let allMarkers = [];

    const globalPreferences = {
      category: "",
      placeType: "",
      mode: "equidistant",
      useTraffic: true,
      scheduled: false,
      scheduleDateTime: null
    };

    // Place type options - SHOPPING REDUCED, MALLS ONLY
    const placeOptions = {
      food: [
        { value: 'restaurant_all', label: 'üçΩÔ∏è All Restaurants', query: '["amenity"="restaurant"]' },
        { value: 'indian', label: 'üçõ Indian Restaurants', query: '["amenity"="restaurant"]["cuisine"~"indian"]' },
        { value: 'chinese', label: 'ü•° Chinese Restaurants', query: '["amenity"="restaurant"]["cuisine"~"chinese"]' },
        { value: 'italian', label: 'üçù Italian Restaurants', query: '["amenity"="restaurant"]["cuisine"~"italian|pizza"]' },
        { value: 'mexican', label: 'üåÆ Mexican Restaurants', query: '["amenity"="restaurant"]["cuisine"~"mexican"]' },
        { value: 'japanese', label: 'üç£ Japanese/Sushi', query: '["amenity"="restaurant"]["cuisine"~"japanese|sushi"]' },
        { value: 'korean', label: 'üçú Korean Restaurants', query: '["amenity"="restaurant"]["cuisine"~"korean"]' },
        { value: 'thai', label: 'ü•ò Thai Restaurants', query: '["amenity"="restaurant"]["cuisine"~"thai"]' },
        { value: 'american', label: 'üçî American Restaurants', query: '["amenity"="restaurant"]["cuisine"~"american|burger"]' },
        { value: 'seafood', label: 'ü¶û Seafood Restaurants', query: '["amenity"="restaurant"]["cuisine"~"seafood"]' },
        { value: 'veg', label: 'ü•ó Vegetarian Restaurants', query: '["amenity"="restaurant"]["diet:vegetarian"="yes"]' },
        { value: 'vegan', label: 'üå± Vegan Restaurants', query: '["amenity"="restaurant"]["diet:vegan"="yes"]' },
        { value: 'bbq', label: 'üçñ BBQ/Grill', query: '["amenity"="restaurant"]["cuisine"~"bbq|grill|steak"]' },
        { value: 'ice_cream', label: 'üç¶ Ice Cream Parlours', query: '["amenity"="ice_cream"]' },
        { value: 'chaat', label: 'ü•ò Chaat/Street Food', query: '["amenity"~"fast_food"]["cuisine"~"indian|street_food"]' },
        { value: 'fast_food', label: 'üçî Fast Food', query: '["amenity"="fast_food"]' },
        { value: 'juice', label: 'ü•§ Juice/Smoothies', query: '["amenity"~"juice_bar|cafe"]["cuisine"~"juice|smoothie"]' },
        { value: 'bakery', label: 'üç∞ Bakery/Desserts', query: '["shop"="bakery"]' },
        { value: 'coffee', label: '‚òï Coffee/Tea House', query: '["amenity"="cafe"]' },
        { value: 'pub', label: 'üçª Pubs & Bars', query: '["amenity"~"pub|bar"]' },
        { value: 'biergarten', label: 'üç∫ Biergarten', query: '["amenity"="biergarten"]' },
      ],
      entertainment: [
        { value: 'cinema', label: 'üé¨ Movie Theaters', query: '["amenity"="cinema"]' },
        { value: 'bowling', label: 'üé≥ Bowling Alleys', query: '["leisure"="bowling_alley"]' },
        { value: 'arcade', label: 'üéÆ Gaming Arcades', query: '["leisure"~"amusement_arcade|gaming_cafe"]' },
        { value: 'escape_room', label: 'üîê Escape Rooms', query: '["leisure"="escape_game"]' },
        { value: 'trampoline', label: 'ü§∏ Trampoline Parks', query: '["leisure"="trampoline_park"]' },
        { value: 'karaoke', label: 'üé§ Karaoke Bars', query: '["amenity"="karaoke_box"]' },
        { value: 'comedy', label: 'üòÇ Comedy Clubs', query: '["amenity"~"nightclub|theatre"]["comedy"="yes"]' },
      ],
      shopping: [
        { value: 'mall', label: 'üè¨ Shopping Malls', query: '["shop"="mall"]' },
        { value: 'books', label: 'üìö Book Stores', query: '["shop"="books"]' },
        { value: 'clothes', label: 'üëï Clothing Stores', query: '["shop"="clothes"]' },
      ],
      sports: [
        { value: 'gym', label: 'üí™ Gyms/Fitness Centers', query: '["leisure"="fitness_centre"]' },
        { value: 'sports_field', label: '‚öΩ Sports Fields', query: '["leisure"~"pitch|sports_centre"]["sport"~"cricket|football|soccer"]' },
        { value: 'yoga', label: 'üßò Yoga Studios', query: '["leisure"="fitness_centre"]["sport"="yoga"]' },
      ],
      outdoor: [
        { value: 'park', label: 'üå≥ Parks & Gardens', query: '["leisure"~"park|garden"]' },
        { value: 'water_park', label: 'üí¶ Water Parks', query: '["leisure"="water_park"]' },
        { value: 'go_kart', label: 'üèéÔ∏è Go Karting', query: '["leisure"="track"]["sport"="karting"]' },
      ],
      culture: [
        { value: 'museum', label: 'üèõÔ∏è Museums', query: '["tourism"="museum"]' },
      ],
      venues: [
        { value: 'party_hall', label: 'üéâ Party Halls', query: '["amenity"~"community_centre|events_venue"]["party"="yes"]' },
        { value: 'wedding_hall', label: 'üíí Wedding Halls', query: '["amenity"~"community_centre|events_venue"]["wedding"="yes"]' },
      ]
    };

    const friendsContainer = document.getElementById("friends-container");
    const resultsContainer = document.getElementById("resultsContainer");
    const mapContainer = document.getElementById("mapContainer");
    const errorBox = document.getElementById("errorBox");
    const findButton = document.getElementById("findButton");
    const btnSpinner = document.getElementById("btnSpinner");
    const categorySelect = document.getElementById("categorySelect");
    const placeTypeSelect = document.getElementById("placeType");
    const placeTypeContainer = document.getElementById("placeTypeContainer");
    const addFriendBtn = document.getElementById("addFriendBtn");
    const trafficToggle = document.getElementById("trafficToggle");
    const scheduleToggle = document.getElementById("scheduleToggle");
    const dateTimeWrapper = document.getElementById("dateTimeWrapper");
    const scheduleDateTime = document.getElementById("scheduleDateTime");
    const modeHelp = document.getElementById("modeHelp");

    // Set default date/time to current + 1 hour
    const now = new Date();
    now.setHours(now.getHours() + 1);
    scheduleDateTime.value = now.toISOString().slice(0, 16);
    scheduleDateTime.min = new Date().toISOString().slice(0, 16);

    function setError(msg) {
      if (!msg) {
        errorBox.style.display = "none";
        errorBox.textContent = "";
      } else {
        errorBox.style.display = "block";
        errorBox.textContent = msg;
      }
    }

    function setLoading(isLoading) {
      findButton.disabled = isLoading;
      btnSpinner.style.display = isLoading ? "inline-block" : "none";
    }

    function getTrafficLevel(currentSpeed, freeFlowSpeed) {
      if (!currentSpeed || !freeFlowSpeed) return null;
      const ratio = currentSpeed / freeFlowSpeed;
      if (ratio < 0.5) return 'heavy';
      if (ratio < 0.75) return 'moderate';
      return 'light';
    }

    categorySelect.addEventListener('change', () => {
      const category = categorySelect.value;
      globalPreferences.category = category;
      
      if (!category) {
        placeTypeContainer.style.display = 'none';
        return;
      }
      
      placeTypeContainer.style.display = 'block';
      placeTypeSelect.innerHTML = '<option value="">Choose...</option>';
      
      const options = placeOptions[category] || [];
      options.forEach(opt => {
        const option = document.createElement('option');
        option.value = opt.value;
        option.textContent = opt.label;
        placeTypeSelect.appendChild(option);
      });
    });

    placeTypeSelect.addEventListener('change', () => {
      globalPreferences.placeType = placeTypeSelect.value;
    });

    trafficToggle.addEventListener('change', (e) => {
      globalPreferences.useTraffic = e.target.checked;
    });

    scheduleToggle.addEventListener('change', (e) => {
      globalPreferences.scheduled = e.target.checked;
      dateTimeWrapper.style.display = e.target.checked ? 'block' : 'none';
    });

    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        const mode = btn.getAttribute('data-mode');
        globalPreferences.mode = mode;
        
        if (mode === 'equidistant') {
          modeHelp.textContent = 'Everyone travels similar distances (most fair).';
        } else {
          modeHelp.textContent = 'Set individual maximum travel ranges for each person.';
        }
        
        const rangeElements = document.querySelectorAll('.range-section');
        rangeElements.forEach(el => {
          if (mode === 'custom') {
            el.classList.add('visible');
          } else {
            el.classList.remove('visible');
          }
        });
      });
    });

    function initMap() {
  const container = L.DomUtil.get('map');
  if (container != null) {
    container._leaflet_id = null;
  }
  
  if (map) {
    map.remove();
    map = null;
  }
  
  mapContainer.classList.add('active');
  
  // FASTER: Initialize immediately without delay
  map = L.map('map', {
    preferCanvas: true,
    zoomControl: true,
    fadeAnimation: false,      // Disable animations
    zoomAnimation: false,
    markerZoomAnimation: false
  }).setView([20.5937, 78.9629], 5);
  
  // FASTER: Optimize tile loading
  L.tileLayer('https://api.tomtom.com/map/1/tile/basic/main/{z}/{x}/{y}.png?tileSize=512&view=Unified&key=' + TOMTOM_API_KEY, {
    attribution: '¬© TomTom',
    maxZoom: 20,
    tileSize: 512,
    zoomOffset: -1,
    updateWhenIdle: true,      // Only load when idle
    updateWhenZooming: false,  // Don't load during zoom
    keepBuffer: 2              // Keep fewer tiles in memory
  }).addTo(map);

  // Force resize once
  map.invalidateSize();
}


    function addMarkersToMap(geocodedFriends, midpoint, scoredPlaces) {
  if (!map) {
    initMap();
  }
 
  addMarkersActually(geocodedFriends, midpoint, scoredPlaces);
}


    function addMarkersActually(geocodedFriends, midpoint, scoredPlaces) {
      allMarkers.forEach(marker => marker.remove());
      allMarkers = [];

      const bounds = [];

      geocodedFriends.forEach((gf) => {
        const marker = L.marker([gf.loc.lat, gf.loc.lon], {
          icon: L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
          })
        }).addTo(map);
        
        const rangeText = globalPreferences.mode === 'custom' ? `<br><small>Max range: ${gf.friend.maxRange} km</small>` : '';
        marker.bindPopup(`<b>${gf.friend.name}</b><br>${gf.loc.formatted}${rangeText}`);
        allMarkers.push(marker);
        bounds.push([gf.loc.lat, gf.loc.lon]);
      });

      const midMarker = L.marker([midpoint.lat, midpoint.lon], {
        icon: L.icon({
          iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-gold.png',
          shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41]
        })
      }).addTo(map);
      
      midMarker.bindPopup('<b>üìç Midpoint</b><br>Fair meeting point');
      allMarkers.push(midMarker);
      bounds.push([midpoint.lat, midpoint.lon]);

      scoredPlaces.slice(0, 10).forEach((item, index) => {
        const place = item.place;
        const marker = L.marker([place.lat, place.lon], {
          icon: L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
          })
        }).addTo(map);
        
        const popupContent = 
          `<b>${place.name}</b>${index === 0 ? ' ‚≠ê' : ''}<br>` +
          `${place.address || place.type}<br>` +
          `<small>Max: ${item.maxTime} min | Avg: ${item.avgTime.toFixed(1)} min</small>`;
        
        marker.bindPopup(popupContent);
        marker.placeIndex = index;
        
        allMarkers.push(marker);
        bounds.push([place.lat, place.lon]);
      });

      if (bounds.length > 0) {
        map.fitBounds(bounds, { padding: [50, 50] });
      }
    }

    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = 
        Math.sin(dLat/2) * Math.sin(dLat/2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    let autocompleteTimeout = null;

    async function fetchAutocompleteSuggestions(text) {
      if (!text || text.length < 3) return [];
      
      const url = 
        "https://apihub.latlong.ai/v4/autocomplete.json?query=" +
        encodeURIComponent(text) +
        "&limit=5";

      try {
        const res = await fetch(url, {
          headers: {
            "X-Authorization-Token": LATLONG_TOKEN,
          },
        });
        
        if (!res.ok) return [];
        
        const data = await res.json();
        if (data.status === 'success' && data.data) {
          return data.data;
        }
        return [];
      } catch (err) {
        console.error("Autocomplete error:", err);
        return [];
      }
    }

    function setupAutocompleteForInput(input, friendId) {
      const container = input.parentElement;
      container.classList.add('autocomplete-container');
      
      const dropdown = document.createElement('div');
      dropdown.className = 'autocomplete-dropdown';
      dropdown.id = `autocomplete-${friendId}`;
      container.appendChild(dropdown);

      input.addEventListener('input', (e) => {
        const text = e.target.value;
        
        clearTimeout(autocompleteTimeout);
        
        if (text.length < 3) {
          dropdown.classList.remove('active');
          return;
        }

        autocompleteTimeout = setTimeout(async () => {
          const suggestions = await fetchAutocompleteSuggestions(text);
          
          if (suggestions.length === 0) {
            dropdown.classList.remove('active');
            return;
          }

          dropdown.innerHTML = '';
          suggestions.forEach(suggestion => {
            const item = document.createElement('div');
            item.className = 'autocomplete-item';
            item.innerHTML = `
              <div class="autocomplete-item-main">${suggestion.name}</div>
            `;
            
            item.addEventListener('click', () => {
              const friend = friends.find(f => f.id === friendId);
              if (friend) {
                friend.location = suggestion.name;
                friend.geoid = suggestion.geoid;
                input.value = suggestion.name;
              }
              dropdown.classList.remove('active');
            });

            dropdown.appendChild(item);
          });

          dropdown.classList.add('active');
        }, 300);
      });

      document.addEventListener('click', (e) => {
        if (!container.contains(e.target)) {
          dropdown.classList.remove('active');
        }
      });
    }

    function addFriend() {
      const friend = {
        id: nextFriendId++,
        name: `Friend ${friends.length + 1}`,
        location: "",
        geoid: null,
        maxRange: 10
      };
      friends.push(friend);
      renderFriends();
    }

    function removeFriend(friendId) {
      friends = friends.filter(f => f.id !== friendId);
      friends.forEach((f, index) => {
        f.name = `Friend ${index + 1}`;
      });
      renderFriends();
    }

    function renderFriends() {
      friendsContainer.innerHTML = "";
      
      if (friends.length === 0) {
        const emptyMsg = document.createElement("div");
        emptyMsg.className = "muted";
        emptyMsg.style.padding = "12px";
        emptyMsg.textContent = "Click 'Add Friend' to start adding locations.";
        friendsContainer.appendChild(emptyMsg);
        return;
      }

      friends.forEach((friend, index) => {
        const div = document.createElement("div");
        div.className = "card friend-card";

        const showRemoveBtn = friends.length > 2;
        const isCustomMode = globalPreferences.mode === 'custom';

        div.innerHTML = `
          <div class="friend-header">
            <span>${friend.name}</span>
            <div style="display:flex;align-items:center;gap:8px;">
              <span style="color:#6b7280;font-size:11px;">Person ${index + 1}</span>
              ${showRemoveBtn ? `<button class="remove-friend-btn" data-friend-id="${friend.id}">Remove</button>` : ''}
            </div>
          </div>

          <div style="margin-bottom:6px;">
            <label>Location (area / landmark)</label>
            <input
              type="text"
              placeholder="e.g. Indiranagar, Marathalli, Varthur"
              value="${friend.location}"
              data-friend-id="${friend.id}"
              data-input-type="location"
            />
            <small class="help">Start typing to see suggestions (min 3 characters).</small>
          </div>

          <div class="range-section ${isCustomMode ? 'visible' : ''}">
            <label>Maximum travel range</label>
            <div class="range-input-container">
              <input 
                type="range" 
                min="1" 
                max="50" 
                value="${friend.maxRange}" 
                data-friend-id="${friend.id}"
                data-input-type="range"
              />
              <span class="range-value" data-friend-id="${friend.id}">${friend.maxRange} km</span>
            </div>
            <small class="help">How far can this person travel?</small>
          </div>
        `;

        friendsContainer.appendChild(div);
      });

      friendsContainer.querySelectorAll("input[data-input-type='location']").forEach((el) => {
        const friendId = Number(el.getAttribute("data-friend-id"));
        
        setupAutocompleteForInput(el, friendId);

        el.addEventListener("input", (e) => {
          const friend = friends.find((f) => f.id === friendId);
          if (friend) {
            friend.location = e.target.value;
          }
        });
      });

      friendsContainer.querySelectorAll("input[data-input-type='range']").forEach((el) => {
        const friendId = Number(el.getAttribute("data-friend-id"));
        
        el.addEventListener("input", (e) => {
          const friend = friends.find((f) => f.id === friendId);
          const value = parseInt(e.target.value);
          if (friend) {
            friend.maxRange = value;
          }
          
          const valueDisplay = friendsContainer.querySelector(`.range-value[data-friend-id="${friendId}"]`);
          if (valueDisplay) {
            valueDisplay.textContent = `${value} km`;
          }
        });
      });

      friendsContainer.querySelectorAll(".remove-friend-btn").forEach((btn) => {
        btn.addEventListener("click", (e) => {
          const friendId = Number(e.target.getAttribute("data-friend-id"));
          removeFriend(friendId);
        });
      });
    }

    addFriend();
    addFriend();
    addFriend();

    addFriendBtn.addEventListener("click", () => {
      addFriend();
    });

    async function geocode(address) {
      const url =
        "https://apihub.latlong.ai/v4/geocode.json?address=" +
        encodeURIComponent(address);

      const res = await fetch(url, {
        headers: {
          "X-Authorization-Token": LATLONG_TOKEN,
        },
      });

      if (!res.ok) throw new Error("Geocoding failed");

      const data = await res.json();
      if (data.status !== "success" || !data.data) {
        throw new Error("Location not found: " + address);
      }

      return {
        lat: parseFloat(data.data.latitude),
        lon: parseFloat(data.data.longitude),
        formatted: data.data.address || address,
      };
    }

    function computeMidpoint(coords) {
      const lat = coords.reduce((sum, c) => sum + c.lat, 0) / coords.length;
      const lon = coords.reduce((sum, c) => sum + c.lon, 0) / coords.length;
      return { lat, lon };
    }

    function getOverpassQueryForPlaceType(placeType) {
      const category = globalPreferences.category;
      const options = placeOptions[category] || [];
      const selected = options.find(opt => opt.value === placeType);
      
      if (selected) {
        return selected.query;
      }
      
      return '["amenity"="restaurant"]';
    }

    async function fetchPlacesNear(mid, placeType, maxRadius) {
      const radiusMeters = globalPreferences.mode === 'custom' 
        ? Math.max(5000, maxRadius * 1000)
        : 10000;
      
      const query = getOverpassQueryForPlaceType(placeType);
      
      const overpassQuery = `
        [out:json][timeout:25];
        (
          node${query}(around:${radiusMeters},${mid.lat},${mid.lon});
          way${query}(around:${radiusMeters},${mid.lat},${mid.lon});
        );
        out center;
      `;

      console.log("Overpass query:", query, "Radius:", radiusMeters);

      try {
        const res = await fetch('https://overpass-api.de/api/interpreter', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: 'data=' + encodeURIComponent(overpassQuery)
        });

        if (!res.ok) {
          throw new Error("Overpass API failed (HTTP " + res.status + ")");
        }

        const data = await res.json();
        
        if (!data.elements || data.elements.length === 0) {
          return [];
        }

        console.log(`Overpass found ${data.elements.length} places`);

        return data.elements
          .filter(elem => elem.tags && elem.tags.name)
          .map(elem => {
            const lat = elem.lat || (elem.center && elem.center.lat);
            const lon = elem.lon || (elem.center && elem.center.lon);
            
            return {
              name: elem.tags.name,
              lat: lat,
              lon: lon,
              address: [
                elem.tags['addr:street'],
                elem.tags['addr:housenumber'],
                elem.tags['addr:city']
              ].filter(Boolean).join(', ') || '',
              type: elem.tags.amenity || elem.tags.shop || elem.tags.leisure || elem.tags.tourism,
              cuisine: elem.tags.cuisine || '',
              phone: elem.tags.phone || elem.tags['contact:phone'] || '',
              website: elem.tags.website || elem.tags['contact:website'] || '',
              opening_hours: elem.tags.opening_hours || '',
              raw: elem.tags
            };
          })
          .filter(p => p.lat !== null && p.lon !== null);
      } catch (err) {
        console.error("Overpass API error:", err);
        throw new Error("Could not fetch places from OpenStreetMap. Please try again.");
      }
    }

    // Enrich place with TomTom POI details
    async function enrichPlaceWithTomTom(place) {
      try {
        const url = `https://api.tomtom.com/search/2/nearbySearch/.json?lat=${place.lat}&lon=${place.lon}&radius=100&limit=1&key=${TOMTOM_API_KEY}`;
        
        const res = await fetch(url);
        if (!res.ok) return place;
        
        const data = await res.json();
        if (data.results && data.results.length > 0) {
          const tomtomPlace = data.results[0];
          
          // Get opening hours from TomTom
          if (tomtomPlace.poi?.openingHours) {
            place.opening_hours_tomtom = tomtomPlace.poi.openingHours.timeRanges || [];
            place.opening_hours_text = tomtomPlace.poi.openingHours.mode || '';
          }
          
          // Get phone if not available
          if (!place.phone && tomtomPlace.poi?.phone) {
            place.phone = tomtomPlace.poi.phone;
          }
          
          // Get website if not available
          if (!place.website && tomtomPlace.poi?.url) {
            place.website = tomtomPlace.poi.url;
          }
          
          place.tomtom_enriched = true;
          console.log(`Enriched ${place.name} with TomTom data`);
        }
      } catch (err) {
        console.warn("TomTom enrichment failed for", place.name, err);
      }
      
      return place;
    }

    async function getTravelTimeMinutes(from, to, useTraffic = false, departureTime = null) {
      if (useTraffic) {
        try {
          let url = `https://api.tomtom.com/routing/1/calculateRoute/${from.lat},${from.lon}:${to.lat},${to.lon}/json?key=${TOMTOM_API_KEY}&travelMode=car`;
          
          if (departureTime) {
            url += `&departAt=${departureTime.toISOString()}`;
            console.log(`Calculating route for departure at: ${departureTime.toLocaleString()}`);
          } else {
            url += '&traffic=true';
          }
          
          const res = await fetch(url);
          if (res.ok) {
            const data = await res.json();
            if (data.routes && data.routes[0]) {
              const route = data.routes[0];
              const summary = route.summary;
              
              const travelTimeSeconds = summary.travelTimeInSeconds;
              const trafficDelaySeconds = summary.trafficDelayInSeconds || 0;
              const distanceMeters = summary.lengthInMeters;
              
              return {
                minutes: Math.round(travelTimeSeconds / 60),
                km: distanceMeters / 1000,
                trafficDelay: Math.round(trafficDelaySeconds / 60),
                currentSpeed: summary.currentSpeed,
                freeFlowSpeed: summary.freeFlowSpeed
              };
            }
          }
        } catch (err) {
          console.warn("TomTom routing failed, falling back:", err);
        }
      }

      const url =
        "https://apihub.latlong.ai/v4/distancematrix.json" +
        "?origins=" +
        encodeURIComponent(`${from.lat},${from.lon}`) +
        "&destinations=" +
        encodeURIComponent(`${to.lat},${to.lon}`);

      const res = await fetch(url, {
        headers: {
          "X-Authorization-Token": LATLONG_TOKEN,
        },
      });

      if (!res.ok) {
        throw new Error("Distance calculation failed");
      }

      const data = await res.json();
      if (!data.data || !data.data.length) {
        throw new Error("No distance returned");
      }

      const first = data.data[0];
      const distStr = first.distance || "";
      const match = distStr.match(/([\d.]+)/);
      if (!match) {
        throw new Error("Invalid distance format: " + distStr);
      }

      const distanceKm = parseFloat(match[1]);
      const avgSpeedKmph = 20;
      const minutes = Math.round((distanceKm / avgSpeedKmph) * 60);

      return { minutes, km: distanceKm };
    }

    async function findFairPlaces() {
      try {
        setError("");
        setLoading(true);
        resultsContainer.className = "results-empty";
        resultsContainer.textContent = "Step 1/5: Finding your locations...";

        if (friends.length < 2) {
          throw new Error("Please add at least 2 friends to find a meeting spot.");
        }

        if (friends.some((f) => !f.location.trim())) {
          throw new Error("Please enter a location for all friends.");
        }

        if (!globalPreferences.category || !globalPreferences.placeType) {
          throw new Error("Please select both a category and specific place type.");
        }

        let departureTime = null;
        if (globalPreferences.scheduled) {
          if (!scheduleDateTime.value) {
            throw new Error("Please select date and time for scheduling.");
          }
          
          departureTime = new Date(scheduleDateTime.value);
          const now = new Date();
          const hoursDiff = (departureTime - now) / (1000 * 60 * 60);
          
          if (hoursDiff < 0) {
            throw new Error("Scheduled time must be in the future.");
          }
          if (hoursDiff > 24) {
            throw new Error("TomTom can only predict traffic up to 24 hours ahead.");
          }
        }

        const geocodedFriends = [];
        for (const friend of friends) {
          const loc = await geocode(friend.location);
          console.log(`Geocoded ${friend.name}:`, loc);
          geocodedFriends.push({ friend, loc });
        }

        resultsContainer.textContent = "Step 2/5: Calculating midpoint...";
        const mid = computeMidpoint(geocodedFriends.map((gf) => gf.loc));

        resultsContainer.textContent = "Step 3/5: Searching for places...";
        
        const maxRange = globalPreferences.mode === 'custom' 
          ? Math.max(...friends.map(f => f.maxRange))
          : 10;
        
        const places = await fetchPlacesNear(mid, globalPreferences.placeType, maxRange);
        console.log(`Found ${places.length} places from OpenStreetMap`);
        
        if (places.length === 0) {
          throw new Error("No places found near the midpoint. Try a different area or place type.");
        }

        resultsContainer.textContent = "Step 4/5: Enriching with TomTom details...";
        
        places.forEach(place => {
          place.straightDistance = calculateDistance(mid.lat, mid.lon, place.lat, place.lon);
        });
        places.sort((a, b) => a.straightDistance - b.straightDistance);
        const closestPlaces = places.slice(0, 30);
        
        // Enrich top 10 with TomTom
        const enrichedPlaces = [];
        for (let i = 0; i < Math.min(10, closestPlaces.length); i++) {
          const enriched = await enrichPlaceWithTomTom(closestPlaces[i]);
          enrichedPlaces.push(enriched);
        }
        
        // Add remaining without enrichment
        for (let i = 10; i < closestPlaces.length; i++) {
          enrichedPlaces.push(closestPlaces[i]);
        }

        const trafficText = globalPreferences.useTraffic 
          ? (departureTime ? ` for ${departureTime.toLocaleString()}` : " with real-time traffic")
          : "";
        resultsContainer.textContent = `Step 5/5: Calculating travel times${trafficText}...`;

        // Process all places in parallel instead of one-by-one
const placePromises = closestPlaces.map(async (place) => {
  try {
    // Calculate travel times for all friends in parallel for this place
    const travelPromises = geocodedFriends.map(gf => 
      getTravelTimeMinutes(gf.loc, place, globalPreferences.useTraffic, departureTime)
    );
    
    // Wait for all friend calculations to complete at once
    const results = await Promise.all(travelPromises);
    
    const times = [];
    const dists = [];
    let trafficInfo = null;
    let withinRange = true;
    
    // Process results
    results.forEach((result, idx) => {
      times.push(result.minutes);
      dists.push(result.km);
      
      if (result.currentSpeed && result.freeFlowSpeed) {
        trafficInfo = {
          currentSpeed: result.currentSpeed,
          freeFlowSpeed: result.freeFlowSpeed,
          delay: result.trafficDelay || 0
        };
      }
      
      // Check custom range
      if (globalPreferences.mode === 'custom' && result.km > geocodedFriends[idx].friend.maxRange) {
        withinRange = false;
      }
    });
    
    if (!withinRange) {
      console.log(`Skipped ${place.name}: outside someone's range`);
      return null;
    }
    
    const maxTime = Math.max(...times);
    const minTime = Math.min(...times);
    const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
    const spread = maxTime - minTime;
    
    let score;
    if (globalPreferences.mode === 'equidistant') {
      score = spread * 3 + avgTime;
    } else {
      score = maxTime * 2 + avgTime + spread;
    }

    const trafficLevel = trafficInfo 
      ? getTrafficLevel(trafficInfo.currentSpeed, trafficInfo.freeFlowSpeed)
      : null;

    return { 
      place, 
      times, 
      dists, 
      maxTime, 
      avgTime, 
      spread, 
      score,
      isEquidistant: spread <= 5,
      trafficLevel,
      trafficInfo,
      scheduledFor: departureTime
    };
  } catch (err) {
    console.warn(`Skipped ${place.name}:`, err.message);
    return null;
  }
});

// Wait for all places to be processed at once
const allResults = await Promise.all(placePromises);

// Filter out null results (places that were skipped)
const scored = allResults.filter(result => result !== null);


        if (scored.length === 0) {
          const modeMsg = globalPreferences.mode === 'custom' 
            ? "No places found within everyone's travel range. Try increasing the ranges or choosing different locations."
            : "Could not calculate travel times. Please try different locations.";
          throw new Error(modeMsg);
        }

        scored.sort((a, b) => a.score - b.score);
        console.log("Top 5 places:", scored.slice(0, 5).map(s => `${s.place.name} (spread: ${s.spread} min)`));
        
        addMarkersToMap(geocodedFriends, mid, scored);
        renderResults(scored, geocodedFriends);
      } catch (err) {
        console.error(err);
        setError(err.message || "Something went wrong. Try again.");
        resultsContainer.className = "results-empty";
        resultsContainer.textContent =
          "Could not calculate suggestions. Check the error message above.";
      } finally {
        setLoading(false);
      }
    }

    function renderResults(scored, geocodedFriends) {
      if (!scored || scored.length === 0) {
        resultsContainer.className = "results-empty";
        resultsContainer.textContent =
          "No suggestions found. Try slightly different areas or a more central location.";
        return;
      }

      resultsContainer.className = "";
      resultsContainer.innerHTML = "";

      const prefDiv = document.createElement("div");
      prefDiv.className = "muted";
      
      const selectedOption = placeOptions[globalPreferences.category]?.find(opt => opt.value === globalPreferences.placeType);
      const placeName = selectedOption ? selectedOption.label : "Places";
      const modeText = globalPreferences.mode === 'equidistant' ? " ¬∑ Equidistant" : " ¬∑ Custom range";
      const trafficText = globalPreferences.useTraffic ? " ¬∑ Traffic-aware" : "";
      const scheduleText = scored[0].scheduledFor ? ` ¬∑ ${scored[0].scheduledFor.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}` : "";
      
      prefDiv.innerHTML = `<strong>Found:</strong> ${placeName} ¬∑ <strong>${scored.length} results</strong>${modeText}${trafficText}${scheduleText}`;
      prefDiv.style.marginBottom = "8px";
      resultsContainer.appendChild(prefDiv);

      scored.forEach((item, index) => {
        const div = document.createElement("div");
        div.className = "place-card" + (index === 0 ? " best" : "");

        const place = item.place;
        // FIXED: Direct GPS coordinates for exact location pin
        const mapsUrl = `https://www.google.com/maps?q=${place.lat},${place.lon}&ll=${place.lat},${place.lon}&z=16&t=m`;


        const friendTimesHtml = geocodedFriends
          .map((gf, i) => {
            const mins = item.times[i];
            const km = item.dists[i];
            const isNearLimit = globalPreferences.mode === 'custom' && km > gf.friend.maxRange * 0.8;
            const warningBadge = isNearLimit ? '<span class="warning-badge">Near limit</span>' : '';
            
            return `
              <div class="muted">
                ${gf.friend.name}: 
                <span style="color:#e5e7eb;">
                  ~${mins} min (~${km.toFixed(1)} km)
                </span>
                ${warningBadge}
              </div>
            `;
          })
          .join("");
        
        let trafficBadge = '';
        if (item.trafficLevel) {
          const trafficLabels = {
            'heavy': 'üî¥ Heavy',
            'moderate': 'üü° Moderate',
            'light': 'üü¢ Light'
          };
          trafficBadge = `<span class="traffic-indicator ${item.trafficLevel}">${trafficLabels[item.trafficLevel]}</span>`;
        }

        // Format opening hours from TomTom
        let placeDetails = '';
        if (place.phone || place.website || place.opening_hours || place.opening_hours_tomtom) {
          placeDetails = `<div class="place-details">`;
          
          if (place.opening_hours_tomtom && place.opening_hours_tomtom.length > 0) {
            const today = new Date().getDay();
            const todayHours = place.opening_hours_tomtom.find(h => h.startDay === today || h.endDay === today);
            if (todayHours) {
              placeDetails += `<div class="detail-item">üïí Today: ${todayHours.startTime} - ${todayHours.endTime}</div>`;
            }
          } else if (place.opening_hours) {
            placeDetails += `<div class="detail-item">üïí ${place.opening_hours}</div>`;
          }
          
          if (place.phone) {
            placeDetails += `<div class="detail-item">üìû <a href="tel:${place.phone}">${place.phone}</a></div>`;
          }

          // FIXED: Only show website from OpenStreetMap (reliable), validate it
          if (place.website && place.website.trim().length > 5) {
            let websiteUrl = place.website.trim();

            // Validate website (skip generic chain sites unless they match)
            const isValidWebsite = (
              !websiteUrl.toLowerCase().includes('starbucks') &&
              !websiteUrl.toLowerCase().includes('mcdonalds') &&
              !websiteUrl.toLowerCase().includes('facebook.com') &&
              (websiteUrl.includes('http://') || websiteUrl.includes('https://') || 
               websiteUrl.includes('.com') || websiteUrl.includes('.in') || 
               websiteUrl.includes('.co'))
            );

            if (isValidWebsite) {
              if (!websiteUrl.startsWith('http://') && !websiteUrl.startsWith('https://')) {
                websiteUrl = 'https://' + websiteUrl;
              }
              placeDetails += `<div class="detail-item">üåê <a href="${websiteUrl}" target="_blank" rel="noopener noreferrer">Website</a></div>`;
            }
          }

          placeDetails += `</div>`;
        }

        div.innerHTML = `
          <div class="place-header">
            <div style="flex:1;">
              <div style="font-weight:600;font-size:14px;display:flex;align-items:center;flex-wrap:wrap;gap:6px;">
                ${place.name}${place.cuisine ? ` (${place.cuisine})` : ''}
                ${trafficBadge}
              </div>
              <div class="muted">
                ${place.address || place.type || 'OpenStreetMap data'}
              </div>
              <div class="muted" style="margin-top:4px;">
                <a href="${mapsUrl}" target="_blank" style="color:#60a5fa;text-decoration:none;">
                  üìç View on Google Maps
                </a>
                <span style="color:#6b7280;font-size:11px;margin-left:8px;">
                  (${place.lat.toFixed(4)}, ${place.lon.toFixed(4)})
                </span>
              </div>
              ${placeDetails}
            </div>
            <div style="display:flex;flex-direction:column;align-items:center;gap:8px;">
              ${index === 0 ? '<span class="badge">Best choice</span>' : ''}
              ${item.isEquidistant ? '<span class="badge equidistant">Equidistant</span>' : ''}
              ${item.scheduledFor ? '<span class="badge scheduled">Scheduled</span>' : ''}
            </div>
          </div>

          <div class="time-row">
            <div>${friendTimesHtml}</div>
            <div style="text-align:right;">
              <div class="muted">
                Max time: <span style="color:#e5e7eb;">${item.maxTime} min</span>
              </div>
              <div class="muted">
                Average: <span style="color:#e5e7eb;">${item.avgTime.toFixed(1)} min</span>
              </div>
              <div class="muted">
                Spread: <span style="color:#e5e7eb;">${item.spread} min</span>
              </div>
            </div>
          </div>
        `;

        div.addEventListener('click', () => {
          if (map && allMarkers.length > 0) {
            const markerIndex = geocodedFriends.length + 1 + index;
            if (markerIndex < allMarkers.length) {
              const marker = allMarkers[markerIndex];
              marker.openPopup();
              map.setView(marker.getLatLng(), 15);
            }
          }
        });

        resultsContainer.appendChild(div);
      });
    }

    findButton.addEventListener("click", () => {
      findFairPlaces();
    });
  </script>
</body>
</html>
